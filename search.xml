<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[shell 常用知识]]></title>
    <url>%2F2018%2F11%2F01%2Fshell%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[学习常用 shell 脚本语法以及命令，用于编写启动脚本以及常用 Linux 操作 shell 变量定义变量时，变量名不加美元符号，如: 1my_name="xush 变量名和等号之间不能有空格，变量的命名遵循以下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头 中间不能有空格，可以使用下划线（ _ ) 不能使用标点符号 不能使用 bash 里面的关键字（help 可以查看保留关键字） 使用变量使用一个已经定义的变量，需要在变量前面加一个 $ 符号， 1echo $&#123;my_name&#125; 花括号可以加可以不加，一般推荐加上，否则编译器可能会识别出错 只读变量可以使用 readonly 命令将变量定义为只读变量，只读变量的值不能被改变 1readonly my_name 删除变量unset 命令可以删除变量 1unset my_name 注意：unset命令不能删除只读变量 变量类型一共存在三种变量 局部变量 在脚本或者命令中定义，只在当前 shell 中生效,其他 shell脚本或者程序无法访问 环境变量 所有的程序，都能访问环境变量，shell 脚本也可以定义环境变量，有的程序需要环境变量才能正常工作 shell 变量 shell 变量是由 shell 程序设置的特殊变量。其中既有环境变量，也有局部变量。 shell 字符串字符串可以使用单引号也可以使用双引号 单引号1string='this is string' 单引号内部的任何字符都会原样输出，内部的变量是无效的，单引号内部不能再出现单个单引号（即使是转义之后），可以出现成对的单引号来拼接字符串使用 双引号1234my_name='lightxxu'string="hello, this is \"$&#123;my_name&#125;\" \n"echo $stringhello, this is "lightxxu 双引号里面可以有变量 双引号里面可以出现转义字符 获取字符串长度12string="1234"echo $&#123;#string&#125; #结果是4 提取子字符串123string="my name is lightxxu"echo $&#123;string:1:4&#125; y na 查找子字符串123string="my name is lightxxu"echo `expr index "$string" io`4 shell 传递参数$# 传递到脚本的参数个数 $ 以一个单字符串显示所有向脚本传递的参数 如 “$“ 会依次输出 “$1 $2 $3 $n”) 相当于一个参数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程ID号 $@ 和 $* 相同，使用时加引号，在引号中返回每个参数 如 ”$@“会依次输出 “$1” “$2” “$3” …”$n” ,相当于多个参数 $- 显示 Shell 使用的当前选项，与 set 命令功能相同 $? 显示最后命令的退出状态，0 表示没有错误，其他任何值表示有错误 12echo &quot;第一个参数: $1&quot;;echo &quot;传参个数为: $#&quot;; 123./test.sh 1 2 3第一个参数: 1传参个数为: 3 shell 数组数组中存放多个值，初始化时不需要定义数组大小，定义时用括号表示，元素用“空格”分割，语法格式如下: 1array = (value1 value2 ... valuen) 也可以使用下标赋值 1array[0] = value1 读取数组元素 1$&#123;array[index]&#125; 获取数组中的所有元素 12echo "数组的元素为:$&#123;array[*]&#125;"echo "数组的元素为:$&#123;array[@]&#125;" 获取数组长度的方法 12echo "数组的元素为:$&#123;#array[*]&#125;"echo "数组的元素为:$&#123;#array[@]&#125;" shell 运算符shell 支持多种运算符 算数运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 原生bash不支持简单的数学运算，可以用expr来支持 12val=`expr 2 + 2`echo "两数之和为：$val" 注意：2 + 2中间要使用空格隔开，expr运算符号要使用包含，而不是单引号 算数运算符a=20 b=10 运算符 说明 实例 + 加法 `expr $a + $b`结果为30 - 减法 `expr $a - $b`结果为10 * 乘法 `expr $a * $b`结果为200 / 除法 `expr $a / $b`结果为2 % 取余数 `expr $a % $b`结果为0 = 赋值 a = $b == 比较相等 [ $a == $b ] 为false ！= 比较不相等 [ $a != $b] 为true 注意 方括号两边要有空格 关系运算符只支持数组，不支持字符串，除非字符串值为数字 运算符 说明 举例 -eq 检测两个数是否相等，是为true [ $a -eq $b ] -ne 检测两个数是否不相等 [ $a -ne $b] -gt greater then 是否大于 [ $a -gt $b] -lt less then 是否小于 [ $a -lt -$b] -ge greater equal 是否大于等于 [ $a -ge -$b] -le less equa 是否小于等于 [ $a -lt -$b] 布尔运算符 运算符 说明 举例 ！ 非运算，返回相反的结果 [ !false ]返回true -o 或运算 ( or ) [ true -o false ] 返回true -a 与运算 ( and ) [ true -a false ] 返回false 逻辑运算符布尔运算符 运算符 说明 举例 &amp;&amp; and [ true &amp;&amp; false ] 返回 false \ \ or [ true \ \ false ] 返回 true 字符串运算符a=”123” b=”456” 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z ( - zero ) 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n “$a” ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 文件测试运算符获取 Unix 文件的属性 操作符 说明 举例 -b file ( - block ) 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file ( -char )检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -d file ( -directory )检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file ( -file )检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file ( -gid ) 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file ( -uid )检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file ( -read )检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file ( -write )检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file ( -execute )检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file ( -space )检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file ( -exist ) 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 echo命令普通字符串echo “this is a string” echo this is a string 转义字符echo \”\“this is a string \“” 输出 “this is a string” 变量echo “$name this is a string” 显示换行12echo -e "line one \n" #-e开启转义echo "line two" 输出 123line oneline two 显示不换行12echo -e "line one \c" $-e开启转义echo "line two" 1line one line two 显示结果定向至文件1echo "this is a string" &gt; file 原样输出1echo '$name\"' 1$name\" 显示命令执行结果1echo `date` 注意：使用的是反引号，不是单引号 test 命令数值测试 参数 说明 -eq 等于则为真 -ne 不等于则为真 -gt 大于则为真 -ge 大于等于则为真 -lt 小于则为真 -le 小于等于则为真 12345678a=100b=100if test $[a] -eq $[b]then echo '两个数相等!'else echo '两个数不相等'fi [ ]用于执行基本的算数运算 字符串测试 参数 说明 = 等于则为真 != 不相等则为真 -z 字符串 字符串的长度为零则为真 -n 字符串 字符串的长度不为零则为真 文件测试类似文件测试运算符 参数 说明 -e 文件 如果文件存在则为真 -r 文件名 如果文件存在且可读则为真 -w 文件名 如果文件存在且可写则为真 -x 文件名 如果文件存在且可执行则为真 -s 文件名 如果文件存在且至少有一个字符则为真 -d 文件名 如果文件存在且为目录则为真 -f 文件名 如果文件存在且为普通文件则为真 -c 文件名 如果文件存在且为字符型特殊文件则为真 -b 文件名 如果文件存在且为块特殊文件则为真 流程控制if else1234567if conditionthen command1 command2else command3fi 123456789if conditionthen command1elif condition2then command2else command3fi 1if condition;then command;fi for1234for var in item1 ... itemNdo commanddone while1234while conditiondo commanddone until执行循环直到条件为true 1234until conditiondo commanddone case12345678case value initem1) command1 ;;item2) command2 ;;esac 跳出循环break continue shell 函数123456[function] function_name( )&#123; action; [return int;]&#125; [function]为函数入参，可有可无 return 为返回值，可有可无 *可以使用 echo 进行返回值]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j2简单使用]]></title>
    <url>%2F2018%2F08%2F09%2Flog4j2%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[目前工作中使用到了 log4j2 的相关配置，做如下记录，以便日后翻阅 日志级别trace：追踪，一般不用 debug：调试用，一般开发，测试过程中使用 debug 日志，debug 日志在正式生产环境中会被关闭，降低性能消耗 info：输出相对重要的信息 warn：警告信息，不一定是错误信息，有些可以不用管 error：错误信息，一般是提示程序运行过程中的异常 fatal：致命错误 输出源CONSOLE (输出到控制台)、FILE (输出到文件) 布局方式SimpleLayout：以简单的形式显示 HTMLLayout：以 HTML 表格显示 PatternLayout：自定义形式显示，一般采用此种方法 自定义格式%t：线程名称 %p：日志级别 %c：日志消息所在类名 %m：消息内容 %M：输出执行方法 %d：时间，%d{yyyy-MM-dd HH:mm:ss,SSS}，输出类似：2018-08-09 16:18:07,659 %x：输出和当前线程相关联的NDC（嵌套诊断环境） %L：代码中的行数 %n：换行 示例： 配置使用配置文件命名与存储位置系统选择configuration文件的优先级如下（放在src文件夹）： classpath下名为 log4j-test.json 或者 log4j-test.jsn 文件 classpath下名为 log4j2-test.xml classpath下名为 log4j.json 或者log4j.jsn文件 classpath下名为 log4j2.xml 下述例子以 log4j2.xml 为例： java 项目中 classpath 一般指 classes（或者bin) 目录和 lib，lib 优先级要高于 classes； 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;configuration status="error"&gt; &lt;!-- 先定义所有的appender --&gt; &lt;appenders&gt; &lt;!-- 这个输出控制台的配置 --&gt; &lt;Console name="Console" target="SYSTEM_OUT"&gt; &lt;!-- 控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） --&gt; &lt;ThresholdFilter level="trace" onMatch="ACCEPT" onMismatch="DENY"/&gt; &lt;!-- 日志输出格式 --&gt; &lt;PatternLayout pattern="%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"/&gt; &lt;/Console&gt; &lt;!-- 文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定 --&gt; &lt;!-- append为TRUE表示消息增加到指定文件中，false表示消息覆盖指定的文件内容，默认值是true --&gt; &lt;File name="log" fileName="log/test.log" append="false"&gt; &lt;PatternLayout pattern="%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"/&gt; &lt;/File&gt; &lt;!-- 添加过滤器ThresholdFilter,可以有选择的输出某个级别以上的类别 onMatch="ACCEPT" onMismatch="DENY"意思是匹配就接受,否则直接拒绝 --&gt; &lt;File name="ERROR" fileName="logs/error.log"&gt; &lt;ThresholdFilter level="error" onMatch="ACCEPT" onMismatch="DENY"/&gt; &lt;PatternLayout pattern="%d&#123;yyyy.MM.dd 'at' HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"/&gt; &lt;/File&gt; &lt;!-- 这个会打印出所有的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档 --&gt; &lt;RollingFile name="RollingFile" fileName="logs/web.log" filePattern="logs/$$&#123;date:yyyy-MM&#125;/web-%d&#123;MM-dd-yyyy&#125;-%i.log.gz"&gt; &lt;PatternLayout pattern="%d&#123;yyyy-MM-dd 'at' HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"/&gt; &lt;SizeBasedTriggeringPolicy size="2MB"/&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;!-- 然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&gt; &lt;loggers&gt; &lt;!-- 异步Logger 业务程序将日志信息放入 Disruptor 队列，程序响应速度更快，对 CPU 消耗更大 --&gt; &lt;!-- additivity=false时不会打印父logger --&gt; &lt;AsyncLogger name="sysLog" level="DEBUG" additivity="false"&gt; &lt;AppenderRef ref="RollingFile"/&gt; &lt;AppenderRef ref="log"/&gt; &lt;/AsyncLogger&gt; &lt;!-- 默认logger --&gt; &lt;root level="trace"&gt; &lt;appender-ref ref="RollingFile"/&gt; &lt;appender-ref ref="Console"/&gt; &lt;appender-ref ref="ERROR" /&gt; &lt;appender-ref ref="log"/&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[centos安装python]]></title>
    <url>%2F2018%2F08%2F03%2Fcentos%E5%AE%89%E8%A3%85python%2F</url>
    <content type="text"><![CDATA[学习一下 python,记录一次在 centos 虚拟机上的安装经历 环境：centos7(Virtual Box) python版本：3.7 centos7 默认会自带 python2，首先查看一下 安装的 python 版本以及位置 1234# python -V# which python/usr/bin/python 进入 bin 目录，查看 python 文件 123456# cd /usr/bin# ls -al python* lrwxrwxrwx. 1 root root 7 Dec 20 2016 python -&gt; python2lrwxrwxrwx. 1 root root 9 Dec 20 2016 python2 -&gt; python2.7-rwxr-xr-x. 1 root root 7136 Nov 6 2016 python2.7 ls -al 参数表示显示所有隐藏文件和目录，并显示所有详细信息 从结果中看到，可执行文件 python 指向 python2 ,python2 又指向 python2.7 ，即 python 默认指向 python2.7 我们先备份 python2.7 123# mv python pyhton.bak# ls python2 python2.7 pyhton.bak 回到 src 目录，通过 wget 下载，外国服务器很慢，需耐心等待 123# cd /usr/local/src # wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tgz# tar -zxvf Python-3.7.0.tgz tar -zxvf 解压到当前目录 执行安装 123# cd Python-3.7.0# ./configure --prefix=/usr/local/python/python3# make &amp;&amp; make altinstall 执行 ./configure 可以创建一个文件 creating Makefile,下面的 make 命令需要用到，执行 make install 便可以安装到指定的目录 –prefix 参数 代表安装的路径，不配的话，可执行文件默认放置到 /usr/local/bin，库文件默认放到 /usr/local/lib，配置文件默认放在 /usr/local/etc ,其他的资源放在 /usr/local/share 安装到一起方便以后的移植和卸载 然后执行 make 、make install 命令，安装完成 我这里使用的是 make altinstall，防止 /usr/bin/目录中出现两个不同版本的 python 接下来需要将默认的共享库加载路径指向 libpython3.7.so所在的目录 123# vim /etc/ld.so.conf//在最后一行添加 "/usr/local/python/python3/lib"# ldconfig 将 python3.7 连接到 /usr/local/bin 1# ln -s /usr/local/python/python3/bin/python3.7 /usr/bin/python python3 到此已经安装完毕 可以确认安装结果 12# python -VPython 3.7.0 还有一件事，这个阶段 yum 一般会出问题 ，修改 /usr/bin/yum 以及 /usr/libexec/urlgrabber-ext-down 两个文件的头，将 #!/usr/bin/python 改成 #!/usr/bin/python2 此时 yum 恢复正常]]></content>
      <tags>
        <tag>python</tag>
        <tag>centos</tag>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
